##  singleton(싱글톤)  
디자인 패턴의 역사상 가장 미움을 받고 있는 디자인 패턴이라고 한다.  
"화장실의 청소솔이 사랑스러워서 사용하는게 아니라, 필요해서 사용하는 것처럼"  
싱글톤도 필요할 때는 사용할 수 있다.  
  
싱글톤은 어떤 인스턴스가 어플리케이션 전체에서 단 하나만 존재해야하는 상황을 처리하기 위한 패턴이다.  
예를 들어, 메모리에 데이터베이스를 로딩하고 읽기 전용 인터페이스를 사용자에게 제공하는 경우, 싱글톤을 사용하면 좋다.  
동일한 데이터를 여러번 로딩해서 메모리를 낭비할 필요가 없기 때문이다.  
  
## 전역 객체, static, 늦은 초기화  
static 전역 객체는 각각의 컴파일 단위 바이너리에서 초기화 순서가 정의되어있지 않다는 문제점이 있다.  
한 모듈에서 전역 객체를 참조할 때 그 전역 객체가 참조하는 또 다른 객체가 아직 초기화되지 않는 상태일 수 있다.  
또 사용자가 이 인터페이스에 전역객체가 있다는 사실을 어떻게 알 수 있는가 하는 문제도 있다.  
그래서 사용자가 더 알기 쉽도록 필요한 객체를 리턴하는 전역함수를 제공하는 방법이 있다.  
::만 입력해서 전역변수의 존재를 알수 있기 때문이다.  
  
## 싱글톤의 문제, 스레드 안정성  
c++11 이상에서는 스레드 안정성이 보장되지만, 그 이하 버전에서는 보장되지 않는다.  
static 객체를 초기화하는 코드 앞 뒤로 컴파일러가 락을 삽입해서  
초기화 와중에 동시에 다른 스레드에서 접근하는 것을 방지해주는지를 확인해야한다.  
  
## 싱글톤의 문제, 싱글톤 내에서 다른 싱글톤을 참조할 경우  
데이터베이스의 소멸자에서 다른 싱글톤 모듈을 참조한다면, 크래시될 가능성이 높다.  
소멸 타이밍을 알수 없기 때문에,, 한 싱글톤 모듈에서 소멸자가 불려서 소멸자에서 참조하는 다른 싱글톤을  소멸하려 할경우, 그 다른 싱글톤 객체를 참조하는 다른 객체들이 있을 가능성이 있기 때문이다.  
이 부분은 소프트웨어 설계 철학 차원에서 싱글톤이 다른 싱글톤을 참조해도 되는가에 대한 문제를 제기한다.  

## 구현 방법
 - 전통적인 구현 방식
 전통적인 방법으로는 static 전역 객체를 사용하는 방법이다.
 static 전역 변수로 관리한다고 해서 인스턴스의 추가 생성을 막을 수는 없기 때문에, 객체가 추가로 생성되는 것을 막는 것이 필요하다.  
 생성자 안에 static 카운터 변수를 두고 값이 증가할 경우 익셉션을 발생시키는 방법이 있다.  
 또 사용자가 생성자를 통해서 생성하지 못하도록 하기 위해 생성자를 private으로 선언한다.  
  
 - 전통적인 구현 방식(전역 객체 대신 객체를 가리키는 static 포인터를 사용)  
 전역 객체 대신 힙메모리를 사용해서 객체를 가리키는 static 포인터를 사용하는 방법이 있다.  
  
 위의 두가지 방법 모두 스레드 안정성의 문제가 있다.  
 컴파일러가 static 객체 초기화 앞 뒤로 락을 삽입하는지 확인이 필요하다.  
 C++11이상 부터는 지원이 되나, 그 이전 버전에서는 지원이 되지 않아서  
 직접 락킹을 하는 코드를 구현해주는 것이 필요하다.  
  
 - 싱글톤에 대한 명시적 의존성을 제거하는 방법  
 기존 구현된 싱글톤 클래스를 사용할 경우, ::get_instance(), ::get()등의 메서드를 부르는 것보다  
 생성자의 인자로 싱글톤 객체를 전달 받는 방식으로 변경함으로서 명시적 의존성을 제거할 수 있다.  
 명시적으로(::get(), ::getInstance()등의) 싱글톤 객체를 사용할 경우, 싱글톤 클래스에 대해 많은 종속성이 발생하게 된다. 코드의 추적이 어려워지게 된다.  
 예제 참고  