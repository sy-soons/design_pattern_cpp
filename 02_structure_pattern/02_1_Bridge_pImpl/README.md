## 브릿지 패턴(pImpl 관례)  
컴파일할 때 번역 단위(translation unit) 전체를 새로 생성하는 대신  
변경된 정의 부분만 새로 만들고 나머지는 재활용해서 컴파일 속도를 줄일 수 있다.  
과거에 개발자들이 컴파일 시간을 단축하기 위해 이런 독특한 관례를 지속적으로 사용해왔다.  
  
## 브릿지 패턴의 장점  
왜 클래스를 이중으로 정의해서 포인터를 왔다 갔다 하는 것일까?
 - 클래스 구현부의 상당 부분이 감춰질 수 있다.  
   Person클래스가 많은 수의 private/protected 멤버를 가진다면  
   헤더를 통해 클라이언트에 노출될 수 있다.  
   (외부에서 사용자가 실제 사용은 할 수 없지만 멤버변수, 함수 등이 불필요하게 노출된다.)  
   pImpl 관례를 사용하면 꼭 필요한 public 인터페이스만 노출할 수 있다.  
    
 - 바이너리 호환성을 보증하기 쉬워진다.  
  숨겨진 구현 클래스에 대한 수정은 바이너리 호환성에 영향을 미치지 않는다.  
    
 - 헤더 파일이 멤버 선언에 필요한 헤더들만 include하게 할 수 있다.  
  구현부때문에 외부에서 이 클래스를 사용하는 클라이언트에서도 필요없는 헤더를 include하지 않아도 된다.  
  Person이 private멤버로 vector<string>을 가진다고 할 때,  
  Person.h 파일 안에서 #include <vector>와 #include <string>을 해야한다.  
  Person.h를 사용하는 모든 사용자는 의도치 않게 <vector>와 <string>을 include하게 된다.  
  하지만 pImpl 관례를 이용하면, Person.cpp에서만 해당 헤더(vector, string)들을 include하면 된다.  
  
이런 장점들로 인해 깨끗하고 자주 바뀌지 않는 안정적인 헤더를 유지할 수 있다.  
컴파일 소요 시간도 줄어든다.  
디자인 패턴 관점에서는 pImpl은 브릿지 패턴의 좋은 예이다.  
멤버 변수 pimpl에는 포인터의 상세 사항이 숨겨져 있고  
이 포인터는 공개용 인터페이스와 숨겨야 할 .cpp파일의 세부구현을 연결하는 다리(브릿지) 역할을 한다.  
  