## 데커레이터  
동료가 작성한 클래스를 기반으로 어떤 기능을 확장해야한다고 해보자.  
원본 코드를 수정하지 않으려면, 가장 쉽게 생각나는 방법은 상속을 이용하는 것이다.  
동료의 클래스를 부모로 하는 자식 클래스를 만들어 새로운 기능들을 추가하고 몇몇 멤버함수들을 오버라이딩 해야할 수도 있다. 이런식으로 원본 코드에 수정을 하지 않고 작업할 수 있다.
  
하지만, 상속을 사용할 수 없는 상황이 있을 수 있다.  
예를 들어 std::vector을 상속받을 경우 vector에는 버추얼 소멸자가 없기때문에 문제가 있을 수 있다.  
그리고 수정하는 이유가 여러가지인 경우 단일 책임 원칙(SRP)에 따라 그 수정 사항들을 각각 완전히 분리하는 것이 바람직하다.  
  
이미 존재하는 타입에 새로운 기능을 추가하면서도 원래 타입의 코드에 수정을 피할 수 있게 해준다.  
(열림-닫힘 원칙(OCP))  
파생해야할 타입의 개수가 과도하게 늘어나는 것도 막을 수 있다.  

## 데커레이터의 필요성  
도형을 나타내는 클래스 Shape가 기존에 존재하고  
이를 상속받아 색상이 있는 도형(ColoredShape)과 투명한 도형(TransparentShape)을 추가했다고 하자.  
두 가지 특성 모두를 필요로 하는 경우가 발생해서 ColoredTransparentShape를 만들면,  
결과적으로 두가지 기능을 추가하기 위해 클래스 3개를 만들게 된다.  
기능이 하나 더 추가되면 더 늘어날 수도 있다.  
  
평범한 상속으로는 효율적으로 새로운 기능을 도형에 추가할 수 없다.  
컴포지션을 활용해야한다.  
데커레이터 패턴에서 객체들에 새로운 기능을 확장할 때 컴포지션을 활용하는데, 이 방식은 다시 두 가지 서로 다른 방식으로 나누어진다.  
  
## 접근 방법  
 - 동적 컴포지션:  
 참조를 주고받으면서 런타임에 동적으로 무언가를 합성할 수 있게 한다.  
 사용자 입력에 따라 런타임에 반응해서 컴포지션을 만들 수 있다.

 - 정적 컴포지션:  
 템플릿을 이용해서 컴파일 시점에 추가기능이 합성되게 한다.  
 코드 작성 시점에 객체에 대한 정확한 추가 기능 조합이 결정되어야 한다.  