## 데커레이터  
동료가 작성한 클래스를 기반으로 어떤 기능을 확장해야한다고 해보자.  
앞에서 언급되었던 OCP원칙에 따라 원본 코드를 수정하지 않고 기능을 확장하는 것이 좋을 것이다.
동료의 클래스를 상속받는 자식클래스를 새로 만들고 새로운 기능을 추가해서 오버라이딩할 수 있겠지만,
상속의 경우, 상속을 사용할 수 없는 제한적인 상황이 있다.
예를 들어 std::vector을 상속받을 경우 vector에는 버추얼 소멸자가 없기때문에 문제가 있을 수 있다.  
그리고 수정하는 이유가 여러가지인 경우 단일 책임 원칙(SRP)에 따라 그 수정 사항들을 각각 완전히 분리하는 것이 바람직하다.  
  
## 컴포저션의 활용
도형을 나타내는 클래스 Shape가 기존에 존재하고 색상이 있는 도형, 투명한 도형, 색상이 있고 투명한 도형이 필요할 경우, 아래처럼 3개의 클래스가 필요하다.
 - 색상이 있는 도형(ColoredShape)
 - 투명한 도형(TransparentShape)
 - ColoredTransparentShape를 만들면,  

결과적으로 두가지 기능을 추가하기 위해 클래스 3개를 만들게 된다. 기능이 하나 더 추가되면 더 늘어날 수도 있다.  
컴포지션을 사용해서 데커레이터 패턴을 구현하면 추후 기능을 확장할 경우 더 유연하게 대응할 수 있다.  
 - 동적 컴포지션:  
 참조를 주고받으면서 런타임에 동적으로 무언가를 합성할 수 있게 한다.  
 사용자 입력에 따라 런타임에 반응해서 컴포지션을 만들 수 있다.
 - 정적 컴포지션:  
 템플릿을 이용해서 컴파일 시점에 추가기능이 합성되게 한다.  
 코드 작성 시점에 객체에 대한 정확한 추가 기능 조합이 결정되어야 한다.  